<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: collection.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: collection.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { BaseObject } from './object';
import { utils } from './utils';
import { Model } from './model';
var setOptions = { add: true, remove: true, merge: true };
var addOptions = { add: true, remove: false };
export class Collection extends BaseObject {
    constructor(models, options = {}) {
        this.options = options;
        if (this.options.model) {
            this.Model = this.options.model;
        }
        //this._byId = {};
        if (models) {
            this.add(models);
        }
        super();
    }
    /**
     * The length of the collection
     * @property {Number} length
     */
    get length() {
        return this.models.length;
    }
    get Model() {
        if (!this._model) {
            this._model = Model;
        }
        return this._model;
    }
    set Model(con) {
        this._model = con;
    }
    get models() {
        return this._models || (this._models = []);
    }
    add(models, options = {}) {
        if (!Array.isArray(models)) {
            if (!(models instanceof this.Model)) {
                models = this.create(models, { add: false });
            }
        }
        else {
            models = models.map((item) => {
                return (item instanceof this.Model) ? item : this.create(item, { add: false });
            });
        }
        this.set(models, utils.extend({ merge: false }, options, addOptions));
    }
    set(items, options = {}) {
        options = utils.extend({}, setOptions, options);
        if (options.parse)
            items = this.parse(items, options);
        var singular = !Array.isArray(items);
        let models = (singular ? (items ? [items] : []) : items.slice());
        var i, l, id, model, attrs, existing, sort;
        var at = options.at;
        //var targetModel = this.model;
        var sortable = this.comparator &amp;&amp; (at == null) &amp;&amp; options.sort !== false;
        var sortAttr = typeof this.comparator === 'string' ? this.comparator : null;
        var toAdd = [], toRemove = [], modelMap = {};
        var add = options.add, merge = options.merge, remove = options.remove;
        var order = !sortable &amp;&amp; add &amp;&amp; remove ? [] : null;
        // Turn bare objects into model references, and prevent invalid models
        // from being added.
        for (i = 0, l = models.length; i &lt; l; i++) {
            model = models[i];
            id = model.get(model.idAttribute) || model.uid;
            // If a duplicate is found, prevent it from being added and
            // optionally merge it into the existing model.
            if (existing = this.get(id)) {
                if (remove)
                    modelMap[existing.uid] = true;
                if (merge) {
                    attrs = model.toJSON();
                    //if (options.parse) attrs = existing.parse(attrs, options);
                    existing.set(attrs, options);
                    if (sortable &amp;&amp; !sort &amp;&amp; existing.hasChanged(sortAttr))
                        sort = true;
                }
                models[i] = existing;
            }
            else if (add) {
                models[i] = model; //this._prepareModel(attrs, options);
                if (!model)
                    continue;
                toAdd.push(model);
                this._addReference(model, options);
            }
            // Do not add multiple models with the same `id`.
            model = existing || model;
            if (order &amp;&amp; !modelMap[model.id])
                order.push(model);
            modelMap[model.uid] = true;
        }
        // Remove nonexistent models if appropriate.
        if (remove) {
            for (i = 0, l = this.length; i &lt; l; ++i) {
                if (!modelMap[(model = this.models[i]).uid])
                    toRemove.push(model);
            }
            if (toRemove.length)
                this.remove(toRemove, options);
        }
        // See if sorting is needed, update `length` and splice in new models.
        if (toAdd.length || (order &amp;&amp; order.length)) {
            if (sortable)
                sort = true;
            //this.length += toAdd.length;
            if (at != null) {
                for (i = 0, l = toAdd.length; i &lt; l; i++) {
                    this.models.splice(at + i, 0, toAdd[i]);
                }
            }
            else {
                if (order)
                    this.models.length = 0;
                var orderedModels = order || toAdd;
                for (i = 0, l = orderedModels.length; i &lt; l; i++) {
                    this.models.push(orderedModels[i]);
                }
            }
        }
        // Silently sort the collection if appropriate.
        if (sort)
            this.sort({ silent: true });
        // Unless silenced, it's time to fire all appropriate add/sort events.
        if (!options.silent) {
            for (i = 0, l = toAdd.length; i &lt; l; i++) {
                (model = toAdd[i]).trigger('add', model, this, options);
            }
            if (sort || (order &amp;&amp; order.length))
                this.trigger('sort', this, options);
            if (toAdd.length || toRemove.length)
                this.trigger('update', this, options);
        }
        // Return the added (or merged) model (or models).
        return singular ? models[0] : models;
    }
    remove(models, options = {}) {
        var singular = !Array.isArray(models);
        models = (singular ? [models] : models.slice());
        var i, l, index, model;
        for (i = 0, l = models.length; i &lt; l; i++) {
            model = models[i] = this.get(models[i]);
            if (!model)
                continue;
            index = this.indexOf(model);
            this.models.splice(index, 1);
            if (!options.silent) {
                options.index = index;
                model.trigger('remove', model, this, options);
            }
            this._removeReference(model, options);
        }
        return singular ? models[0] : models;
    }
    get(id) {
        return this.find(id);
    }
    // Get the model at the given index.
    at(index) {
        return this.models[index];
    }
    clone(options) {
        options = options || this.options;
        return new this.constructor(this.models, options);
    }
    sort(options = {}) {
        if (!this.comparator)
            throw new Error('Cannot sort a set without a comparator');
        // Run sort based on type of `comparator`.
        if (typeof this.comparator === 'string' || this.comparator.length === 1) {
            this._models = this.sortBy(this.comparator, this);
        }
        else {
            this.models.sort(this.comparator.bind(this));
        }
        if (!options.silent)
            this.trigger('sort', this, options);
        return this;
    }
    sortBy(key, context) {
        return utils.sortBy(this._models, key, context);
    }
    push(model, options = {}) {
        return this.add(model, utils.extend({ at: this.length }, options));
    }
    reset(models, options = {}) {
        this.forEach((model) => {
            this._removeReference(model, options);
        });
        options.previousModels = this.models;
        this._reset();
        models = this.add(models, options);
        if (!options.silent)
            this.trigger('reset', this, options);
        return models;
    }
    create(values, options = { add: true }) {
        let model = new this.Model(values, options);
        if (options.add)
            this.add(model);
        return model;
    }
    parse(models, options = {}) {
        return models;
    }
    find(nidOrFn) {
        let model;
        if (typeof nidOrFn === 'function') {
            model = utils.find(this.models, nidOrFn);
        }
        else {
            model = utils.find(this.models, function (model) {
                return model.id == nidOrFn || model.uid == nidOrFn || nidOrFn === model;
            });
        }
        return model;
    }
    forEach(iterator, ctx) {
        for (let i = 0, l = this.models.length; i &lt; l; i++) {
            iterator.call(ctx || this, this.models[i], i);
        }
        return this;
    }
    indexOf(model) {
        return this.models.indexOf(model);
    }
    toJSON() {
        return this.models.map(function (m) { return m.toJSON(); });
    }
    comparator() { }
    _removeReference(model, options) {
        if (this === model.collection)
            delete model.collection;
        this.stopListening(model);
    }
    _addReference(model, options) {
        if (!model.collection)
            model.collection = this;
        this.listenTo(model, 'all', this._onModelEvent);
    }
    _reset() {
        this._models = [];
    }
    _onModelEvent(event, model, collection, options) {
        if ((event === 'add' || event === 'remove') &amp;&amp; collection !== this)
            return;
        if (event === 'destroy')
            this.remove(model, options);
        utils.call(this.trigger, this, utils.slice(arguments));
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="-_.html"></a></li><li><a href="BaseObject.html">BaseObject</a></li><li><a href="BaseView.html">BaseView</a></li><li><a href="CollectionView.html">CollectionView</a></li><li><a href="DataView.html">DataView</a></li><li><a href="LayoutView.html">LayoutView</a></li><li><a href="Region.html">Region</a></li><li><a href="RegionManager.html">RegionManager</a></li><li><a href="TemplateView.html">TemplateView</a></li><li><a href="View.html">View</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Thu Aug 13 2015 22:22:18 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
