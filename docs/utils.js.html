<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var ElementProto = (typeof Element !== 'undefined' &amp;&amp; Element.prototype) || {};
var matchesSelector = ElementProto.matches ||
    ElementProto.webkitMatchesSelector ||
    ElementProto.mozMatchesSelector ||
    ElementProto.msMatchesSelector ||
    ElementProto.oMatchesSelector || function (selector) {
    var nodeList = (this.parentNode || document).querySelectorAll(selector) || [];
    return !!~utils.indexOf(nodeList, this);
};
var elementAddEventListener = ElementProto.addEventListener || function (eventName, listener) {
    return this.attachEvent('on' + eventName, listener);
};
var elementRemoveEventListener = ElementProto.removeEventListener || function (eventName, listener) {
    return this.detachEvent('on' + eventName, listener);
};
export function extend(protoProps, staticProps) {
    var parent = this;
    var child;
    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps &amp;&amp; utils.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    }
    else {
        child = function () { return parent.apply(this, arguments); };
    }
    // Add static properties to the constructor function, if supplied.
    utils.extend(child, parent, staticProps);
    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function () { this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;
    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps)
        utils.extend(child.prototype, protoProps);
    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;
    return child;
}
export var html;
(function (html) {
    function matches(elm, selector) {
        return matchesSelector.call(elm, selector);
    }
    html.matches = matches;
    function addEventListener(elm, eventName, listener, useCap = false) {
        elementAddEventListener.call(elm, eventName, listener, useCap);
    }
    html.addEventListener = addEventListener;
    function removeEventListener(elm, eventName, listener) {
        elementRemoveEventListener.call(elm, eventName, listener);
    }
    html.removeEventListener = removeEventListener;
    function addClass(elm, className) {
        if (elm.classList)
            elm.classList.add(className);
        else {
            elm.className = elm.className.split(' ').concat(className.split(' ')).join(' ');
        }
    }
    html.addClass = addClass;
    function removeClass(elm, className) {
        if (elm.classList)
            elm.classList.remove(className);
        else {
            elm.className = elm.className.split(' ').concat(className.split(' ')).join(' ');
        }
    }
    html.removeClass = removeClass;
})(html || (html = {}));
const nativeBind = Function.prototype.bind;
const noop = function () { };
let idCounter = 0;
/** @module utils */
export var utils;
(function (utils) {
    function camelcase(input) {
        return input.toLowerCase().replace(/-(.)/g, function (match, group1) {
            return group1.toUpperCase();
        });
    }
    utils.camelcase = camelcase;
    ;
    /** Generate an unique id with an optional prefix
     * @param {string} prefix
     * @return {string}
     */
    function uniqueId(prefix = '') {
        return prefix + (++idCounter);
    }
    utils.uniqueId = uniqueId;
    function isObject(obj) {
        return obj === Object(obj);
    }
    utils.isObject = isObject;
    function extend(obj, ...args) {
        if (!utils.isObject(obj))
            return obj;
        let o, k;
        for (o of args) {
            if (!utils.isObject(o))
                continue;
            for (k in o) {
                if (utils.has(o, k))
                    obj[k] = o[k];
            }
        }
        return obj;
    }
    utils.extend = extend;
    function pick(obj, props) {
        let out = {}, prop;
        for (prop of props) {
            if (utils.has(obj, prop))
                out[prop] = obj[prop];
        }
        return out;
    }
    utils.pick = pick;
    function has(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    utils.has = has;
    function indexOf(array, item) {
        for (var i = 0, len = array.length; i &lt; len; i++)
            if (array[i] === item)
                return i;
        return -1;
    }
    utils.indexOf = indexOf;
    function result(obj, prop, ctx, args) {
        let ret = obj[prop];
        return (typeof ret === 'function') ? utils.call(ret, ctx, args || []) : ret;
    }
    utils.result = result;
    function values(obj) {
        let output = [];
        for (let k in obj)
            if (utils.has(obj, k)) {
                output.push(obj[k]);
            }
        return output;
    }
    utils.values = values;
    function find(array, callback, ctx) {
        let i, v;
        for (i = 0; i &lt; array.length; i++) {
            v = array[i];
            if (callback.call(ctx, v))
                return v;
        }
        return null;
    }
    utils.find = find;
    function proxy(from, to, fns) {
        if (!Array.isArray(fns))
            fns = [fns];
        fns.forEach(function (fn) {
            if (typeof to[fn] === 'function') {
                from[fn] = utils.bind(to[fn], to);
            }
        });
    }
    utils.proxy = proxy;
    function bind(method, context, ...args) {
        if (typeof method !== 'function')
            throw new Error('method not at function');
        if (nativeBind != null)
            return nativeBind.call(method, context, ...args);
        args = args || [];
        let fnoop = function () { };
        let fBound = function () {
            let ctx = this instanceof fnoop ? this : context;
            return utils.call(method, ctx, args.concat(utils.slice(arguments)));
        };
        fnoop.prototype = this.prototype;
        fBound.prototype = new fnoop();
        return fBound;
    }
    utils.bind = bind;
    function call(fn, ctx, args = []) {
        switch (args.length) {
            case 0:
                return fn.call(ctx);
            case 1:
                return fn.call(ctx, args[0]);
            case 2:
                return fn.call(ctx, args[0], args[1]);
            case 3:
                return fn.call(ctx, args[0], args[1], args[2]);
            case 4:
                return fn.call(ctx, args[0], args[1], args[2], args[3]);
            case 5:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
            default:
                return fn.apply(ctx, args);
        }
    }
    utils.call = call;
    function slice(array) {
        return Array.prototype.slice.call(array);
    }
    utils.slice = slice;
    function equal(a, b) {
        return eq(a, b, [], []);
    }
    utils.equal = equal;
    function triggerMethodOn(obj, eventName, args) {
        let ev = camelcase("on-" + eventName.replace(':', '-'));
        if (obj[ev] &amp;&amp; typeof obj[ev] === 'function') {
            utils.call(obj[ev], obj, args);
        }
        if (typeof obj.trigger === 'function') {
            args = [eventName].concat(args);
            utils.call(obj.trigger, obj, args);
        }
    }
    utils.triggerMethodOn = triggerMethodOn;
    function getOption(option, objs) {
        for (let o of objs) {
            if (isObject(o) &amp;&amp; o[option])
                return o[option];
        }
        return null;
    }
    utils.getOption = getOption;
    function sortBy(obj, value, context) {
        var iterator = typeof value === 'function' ? value : function (obj) { return obj[value]; };
        return obj
            .map(function (value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iterator.call(context, value, index, list)
            };
        })
            .sort(function (left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0)
                    return 1;
                if (a &lt; b || b === void 0)
                    return -1;
            }
            return left.index - right.index;
        })
            .map(function (item) {
            return item.value;
        });
    }
    utils.sortBy = sortBy;
})(utils || (utils = {}));
function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
        return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null)
        return a === b;
    // Unwrap any wrapped objects.
    //if (a instanceof _) a = a._wrapped;
    //if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b))
        return false;
    switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return a == String(b);
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
            // other numeric values.
            return a !== +a ? b !== +b : (a === 0 ? 1 / a === 1 / b : a === +b);
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source == b.source &amp;&amp;
                a.global == b.global &amp;&amp;
                a.multiline == b.multiline &amp;&amp;
                a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
        return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a)
            return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor &amp;&amp; !(typeof aCtor === 'function' &amp;&amp; (aCtor instanceof aCtor) &amp;&amp;
        typeof bCtor === 'function' &amp;&amp; (bCtor instanceof bCtor))) {
        return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size === b.length;
        if (result) {
            // Deep compare the contents, ignoring non-numeric properties.
            while (size--) {
                if (!(result = eq(a[size], b[size], aStack, bStack)))
                    break;
            }
        }
    }
    else {
        // Deep compare objects.
        for (var key in a) {
            if (utils.has(a, key)) {
                // Count the expected number of properties.
                size++;
                // Deep compare each member.
                if (!(result = utils.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack)))
                    break;
            }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
            for (key in b) {
                if (utils.has(b, key) &amp;&amp; !(size--))
                    break;
            }
            result = !size;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
}
;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="-_.html"></a></li><li><a href="BaseObject.html">BaseObject</a></li><li><a href="BaseView.html">BaseView</a></li><li><a href="CollectionView.html">CollectionView</a></li><li><a href="DataView.html">DataView</a></li><li><a href="LayoutView.html">LayoutView</a></li><li><a href="Region.html">Region</a></li><li><a href="RegionManager.html">RegionManager</a></li><li><a href="TemplateView.html">TemplateView</a></li><li><a href="View.html">View</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Thu Aug 13 2015 19:31:34 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
