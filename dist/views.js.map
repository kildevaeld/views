{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 14bc67f0ccb1be0a9f69","webpack:///./lib/index.js","webpack:///./lib/baseview.js","webpack:///./~/debug/browser.js","webpack:///./~/debug/debug.js","webpack:///./~/ms/index.js","webpack:///./lib/object.js","webpack:///./~/eventsjs/lib/events.js","webpack:///./~/orange/index.js","webpack:///./~/orange/utils.js","webpack:///./~/orange/functions.js","webpack:///./~/orange/arrays.js","webpack:///./~/orange/strings.js","webpack:///./~/orange/objects.js","webpack:///./~/orange/promises.js","webpack:///./~/orange/map.js","webpack:///./lib/util.js","webpack:///./lib/region.js","webpack:///./lib/region-manager.js","webpack:///./lib/layout-view.js","webpack:///./lib/view.js","webpack:///./lib/collection-view.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/lib/b64.js","webpack:///./~/ieee754/index.js","webpack:///./~/buffer/~/isarray/index.js","webpack:///./lib/annotations.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,qCAAqC;AAC/C;AACA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,2BAA2B,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iFAAiF;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,mBAAmB;AAClC,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B,gBAAe,OAAO;AACtB,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B,iBAAgB;AAChB;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,oBAAoB,IAAI,SAAS;AACpD;AACA;AACA;;;;;;;;AC3UA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B,6BAA4B;AAC5B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA,+BAA8B,cAAc;AAC5C,+DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,cAAc;AAC5C;AACA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,sCAAsC;AACnE;AACA;AACA;AACA;AACA;AACA,kCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,uCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,0EAAyE,mBAAmB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;;;;;;ACrKA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,aAAY,OAAO,0BAA0B,UAAU,kBAAkB;AACzE,aAAY,OAAO,2CAA2C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,QAAQ;AAC1C;AACA,0DAAyD,sCAAsC,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,6BAA4B;AAC5B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,eAAe,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,iBAAiB,eAAe,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,kBAAkB,EAAE;AACjE;AACA;AACA;AACA;AACA,wCAAuC,mBAAmB,EAAE;AAC5D;AACA;AACA;AACA;AACA,8CAA6C,2BAA2B,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/HA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,eAAe;AACrC,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC,gBAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,uBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,QAAQ,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,MAAM;AACtB,iBAAgB,OAAO;AACvB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,yBAAwB,QAAQ;AAChC;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5vDA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"views.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"views\"] = factory();\n\telse\n\t\troot[\"views\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 14bc67f0ccb1be0a9f69\n **/","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst baseview_1 = require('./baseview');\n__export(require('./object'));\n__export(require('./baseview'));\n__export(require('./region'));\n__export(require('./region-manager'));\n__export(require('./layout-view'));\n__export(require('./view'));\n__export(require('./collection-view'));\n__export(require('./annotations'));\nexports.Version = '0.2.14';\nfunction debug(debug) {\n    if (window.localStorage) {\n        window.localStorage['debug'] = debug ? \"views:*\" : '';\n    }\n}\nexports.debug = debug;\n//export {Collection, ICollection,IModel,Model} from 'collection'\nfunction isView(a) {\n    return a instanceof baseview_1.BaseView;\n}\nexports.isView = isView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\nconst debug = require('debug')('views:baseview');\nconst object_1 = require('./object');\nconst utils = require('orange');\nconst util_1 = require('./util');\nconst paddedLt = /^\\s*</;\nconst unbubblebles = 'focus blur change'.split(' ');\nlet viewOptions = ['el', 'id', 'attributes', 'className', 'tagName', 'events', 'triggers', 'ui'];\nclass BaseView extends object_1.BaseObject {\n    /**\n     * BaseView\n     * @param {BaseViewOptions} options\n     * @extends BaseObject\n     */\n    constructor(options = {}) {\n        super();\n        this._cid = utils.uniqueId('view');\n        utils.extend(this, utils.pick(options, viewOptions));\n        this._domEvents = [];\n        if (this.el == null) {\n            this._ensureElement();\n        }\n    }\n    static find(selector, context) {\n        return context.querySelectorAll(selector);\n    }\n    get cid() {\n        return this._cid;\n    }\n    /**\n     * Delegate events\n     * @param {EventsMap} events\n     */\n    delegateEvents(events) {\n        this._bindUIElements();\n        events = events || utils.result(this, 'events');\n        events = util_1.normalizeUIKeys(events, this._ui);\n        let triggers = this._configureTriggers();\n        events = utils.extend({}, events, triggers);\n        debug('%s delegate events %j', this, events);\n        if (!events)\n            return this;\n        //if (!(events || (events = utils.result(this, 'events')))) return this;\n        //this.undelegateEvents();\n        let dels = [];\n        for (let key in events) {\n            let method = events[key];\n            if (typeof method !== 'function')\n                method = this[method];\n            let match = key.match(/^(\\S+)\\s*(.*)$/);\n            // Set delegates immediately and defer event on this.el\n            let boundFn = utils.bind(method, this);\n            if (match[2]) {\n                this.delegate(match[1], match[2], boundFn);\n            }\n            else {\n                dels.push([match[1], boundFn]);\n            }\n        }\n        dels.forEach(d => { this.delegate(d[0], d[1]); });\n        return this;\n    }\n    /**\n     * Undelegate events\n     */\n    undelegateEvents() {\n        this._unbindUIElements();\n        debug('%s undelegate events', this);\n        if (this.el) {\n            for (var i = 0, len = this._domEvents.length; i < len; i++) {\n                var item = this._domEvents[i];\n                utils.removeEventListener(this.el, item.eventName, item.handler);\n            }\n            this._domEvents.length = 0;\n        }\n        return this;\n    }\n    delegate(eventName, selector, listener) {\n        if (typeof selector === 'function') {\n            listener = selector;\n            selector = null;\n        }\n        let root = this.el;\n        let handler = selector ? function (e) {\n            let node = e.target || e.srcElement;\n            // Already handled\n            if (e.delegateTarget)\n                return;\n            for (; node && node != root; node = node.parentNode) {\n                if (utils.matches(node, selector)) {\n                    e.delegateTarget = node;\n                    listener(e);\n                }\n            }\n        } : function (e) {\n            if (e.delegateTarget)\n                return;\n            listener(e);\n        };\n        /*jshint bitwise: false*/\n        let useCap = !!~unbubblebles.indexOf(eventName) && selector != null;\n        debug('%s delegate event %s ', this, eventName);\n        utils.addEventListener(this.el, eventName, handler, useCap);\n        this._domEvents.push({ eventName: eventName, handler: handler, listener: listener, selector: selector });\n        return handler;\n    }\n    undelegate(eventName, selector, listener) {\n        if (typeof selector === 'function') {\n            listener = selector;\n            selector = null;\n        }\n        if (this.el) {\n            var handlers = this._domEvents.slice();\n            for (var i = 0, len = handlers.length; i < len; i++) {\n                var item = handlers[i];\n                var match = item.eventName === eventName &&\n                    (listener ? item.listener === listener : true) &&\n                    (selector ? item.selector === selector : true);\n                if (!match)\n                    continue;\n                utils.removeEventListener(this.el, item.eventName, item.handler);\n                this._domEvents.splice(utils.indexOf(handlers, item), 1);\n            }\n        }\n        return this;\n    }\n    render(options) {\n        this.undelegateEvents();\n        this.delegateEvents();\n        return this;\n    }\n    /**\n     * Append the view to a HTMLElement\n     * @param {HTMLElement|string} elm A html element or a selector string\n     * @return {this} for chaining\n     */\n    appendTo(elm) {\n        if (elm instanceof HTMLElement) {\n            elm.appendChild(this.el);\n        }\n        else {\n            let el = document.querySelector(elm);\n            el ? el.appendChild(this.el) : void 0;\n        }\n        return this;\n    }\n    /**\n     * Append a element the view\n     * @param {HTMLElement} elm\n     * @param {String} toSelector\n     * @return {this} for chaining\n     */\n    append(elm, toSelector) {\n        if (toSelector != null) {\n            let ret = this.$(toSelector);\n            if (ret instanceof NodeList && ret.length > 0) {\n                ret[0].appendChild(elm);\n            }\n            else if (ret instanceof HTMLElement) {\n                ret.appendChild(elm);\n            }\n        }\n        else {\n            this.el.appendChild(elm);\n        }\n        return this;\n    }\n    /**\n     * Convience for view.el.querySelectorAll()\n     * @param {string|HTMLElement} selector\n     */\n    $(selector) {\n        if (selector instanceof HTMLElement) {\n            return selector;\n        }\n        else {\n            return BaseView.find(selector, this.el);\n        }\n    }\n    setElement(elm, trigger = true) {\n        this.triggerMethod('before:set:element');\n        if (trigger)\n            this.undelegateEvents();\n        this._setElement(elm);\n        if (trigger)\n            this.delegateEvents();\n        this.triggerMethod('set:element');\n    }\n    remove() {\n        this._removeElement();\n        return this;\n    }\n    destroy() {\n        if (this.isDestroyed)\n            return;\n        this.remove();\n        super.destroy();\n        return this;\n    }\n    // PRIVATES\n    /**\n     * Bind ui elements\n     * @private\n     */\n    _bindUIElements() {\n        let ui = this.getOption('ui'); //this.options.ui||this.ui\n        if (!ui)\n            return;\n        if (!this._ui) {\n            this._ui = ui;\n        }\n        ui = utils.result(this, '_ui');\n        this.ui = {};\n        Object.keys(ui).forEach((k) => {\n            let elm = this.$(ui[k]);\n            if (elm && elm.length) {\n                // unwrap if it's a nodelist.\n                if (elm instanceof NodeList) {\n                    elm = elm[0];\n                }\n                debug('%s added ui element %s %s', this, k, ui[k]);\n                this.ui[k] = elm;\n            }\n            else {\n                debug('%s ui element not found ', this, k, ui[k]);\n            }\n        });\n    }\n    /**\n     * Unbind ui elements\n     * @private\n     */\n    _unbindUIElements() {\n    }\n    /**\n     * Configure triggers\n     * @return {Object} events object\n     * @private\n     */\n    _configureTriggers() {\n        let triggers = this.getOption('triggers') || {};\n        if (typeof triggers === 'function') {\n            triggers = triggers.call(this);\n        }\n        // Allow `triggers` to be configured as a function\n        triggers = util_1.normalizeUIKeys(triggers, this._ui);\n        // Configure the triggers, prevent default\n        // action and stop propagation of DOM events\n        let events = {}, val, key;\n        for (key in triggers) {\n            val = triggers[key];\n            debug('%s added trigger %s %s', this, key, val);\n            events[key] = this._buildViewTrigger(val);\n        }\n        return events;\n    }\n    /**\n     * builder trigger function\n     * @param  {Object|String} triggerDef Trigger definition\n     * @return {Function}\n     * @private\n     */\n    _buildViewTrigger(triggerDef) {\n        if (typeof triggerDef === 'string')\n            triggerDef = { event: triggerDef };\n        let options = utils.extend({\n            preventDefault: true,\n            stopPropagation: true\n        }, triggerDef);\n        return function (e) {\n            if (e) {\n                if (e.preventDefault && options.preventDefault) {\n                    e.preventDefault();\n                }\n                if (e.stopPropagation && options.stopPropagation) {\n                    e.stopPropagation();\n                }\n            }\n            this.triggerMethod(options.event, {\n                view: this,\n                model: this.model,\n                collection: this.collection\n            });\n        };\n    }\n    _createElement(tagName) {\n        return document.createElement(tagName);\n    }\n    _ensureElement() {\n        if (!this.el) {\n            var attrs = utils.extend({}, utils.result(this, 'attributes'));\n            if (this.id)\n                attrs.id = utils.result(this, 'id');\n            if (this.className)\n                attrs['class'] = utils.result(this, 'className');\n            debug('%s created element: %s', this, utils.result(this, 'tagName') || 'div');\n            this.setElement(this._createElement(utils.result(this, 'tagName') || 'div'), false);\n            this._setAttributes(attrs);\n        }\n        else {\n            this.setElement(utils.result(this, 'el'), false);\n        }\n    }\n    _removeElement() {\n        this.undelegateEvents();\n        if (this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    }\n    _setElement(element) {\n        if (typeof element === 'string') {\n            if (paddedLt.test(element)) {\n                let el = document.createElement('div');\n                el.innerHTML = element;\n                this.el = el.firstElementChild;\n            }\n            else {\n                this.el = document.querySelector(element);\n            }\n        }\n        else {\n            this.el = element;\n        }\n    }\n    _setAttributes(attrs) {\n        for (var attr in attrs) {\n            attr in this.el ? this.el[attr] = attrs[attr] : this.el.setAttribute(attr, attrs[attr]);\n        }\n    }\n    toString() {\n        return `[${this.name || 'View'}: ${this.cid}]`;\n    }\n}\nexports.BaseView = BaseView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/baseview.js\n ** module id = 1\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/debug.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ms/index.js\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\nconst debug = require('debug')('views:object');\nconst eventsjs_1 = require('eventsjs');\nconst orange_1 = require('orange');\n/** Base object */\nclass BaseObject extends eventsjs_1.EventEmitter {\n    /**\n     * Object\n     * @extends EventEmitter\n     */\n    constructor(args) {\n        super();\n        this._isDestroyed = false;\n    }\n    /**\n     * Whether the object is \"destroyed\" or not\n     * @type boolean\n     */\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this.isDestroyed)\n            return this;\n        this.triggerMethod('before:destroy');\n        this.stopListening();\n        this.off();\n        this._isDestroyed = true;\n        this.triggerMethod('destroy');\n        debug(\"%s destroy\", this);\n        if (typeof Object.freeze) {\n        }\n        return this;\n    }\n    triggerMethod(eventName, ...args) {\n        orange_1.triggerMethodOn(this, eventName, args);\n        return this;\n    }\n    getOption(prop, ...args) {\n        if (this.options) {\n            args.push(this.options);\n        }\n        if (this._options) {\n            args.push(this._options);\n        }\n        args.push(this);\n        return orange_1.getOption(prop, args);\n    }\n}\nBaseObject.extend = function (proto, stat) {\n    return orange_1.inherits(this, proto, stat);\n};\nexports.BaseObject = BaseObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/object.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\nvar idCounter = 0;\nfunction getID() {\n    return \"\" + (++idCounter);\n}\nfunction callFunc(fn, args) {\n    if (args === void 0) { args = []; }\n    var l = fn.length, i = -1, a1 = args[0], a2 = args[1], a3 = args[2], a4 = args[3];\n    switch (args.length) {\n        case 0:\n            while (++i < l)\n                fn[i].handler.call(fn[i].ctx);\n            return;\n        case 1:\n            while (++i < l)\n                fn[i].handler.call(fn[i].ctx, a1);\n            return;\n        case 2:\n            while (++i < l)\n                fn[i].handler.call(fn[i].ctx, a1, a2);\n            return;\n        case 3:\n            while (++i < l)\n                fn[i].handler.call(fn[i].ctx, a1, a2, a3);\n            return;\n        case 4:\n            while (++i < l)\n                fn[i].handler.call(fn[i].ctx, a1, a2, a3, a4);\n            return;\n        default:\n            while (++i < l)\n                fn[i].handler.apply(fn[i].ctx, args);\n            return;\n    }\n}\nexports.callFunc = callFunc;\nfunction isFunction(a) {\n    return typeof a === 'function';\n}\nexports.isFunction = isFunction;\nfunction isEventEmitter(a) {\n    return a instanceof EventEmitter || (isFunction(a.on) && isFunction(a.off) && isFunction(a.trigger));\n}\nexports.isEventEmitter = isEventEmitter;\nvar EventEmitter = (function () {\n    function EventEmitter() {\n    }\n    Object.defineProperty(EventEmitter.prototype, \"listeners\", {\n        get: function () {\n            return this._listeners;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EventEmitter.prototype.on = function (event, fn, ctx, once) {\n        if (once === void 0) { once = false; }\n        var events = (this._listeners || (this._listeners = {}))[event] || (this._listeners[event] = []);\n        events.push({\n            name: event,\n            once: once,\n            handler: fn,\n            ctx: ctx || this\n        });\n        return this;\n    };\n    EventEmitter.prototype.once = function (event, fn, ctx) {\n        return this.on(event, fn, ctx, true);\n    };\n    EventEmitter.prototype.off = function (eventName, fn) {\n        this._listeners = this._listeners || {};\n        if (eventName == null) {\n            this._listeners = {};\n        }\n        else if (this._listeners[eventName]) {\n            var events = this._listeners[eventName];\n            if (fn == null) {\n                this._listeners[eventName] = [];\n            }\n            else {\n                for (var i = 0; i < events.length; i++) {\n                    var event_1 = events[i];\n                    if (events[i].handler == fn) {\n                        this._listeners[eventName].splice(i, 1);\n                    }\n                }\n            }\n        }\n    };\n    EventEmitter.prototype.trigger = function (eventName) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        //let events = (this._listeners|| (this._listeners = {}))[eventName]||(this._listeners[eventName]=[])\n        //.concat(this._listeners['all']||[])\n        this._listeners = this._listeners || {};\n        var events = (this._listeners[eventName] || []).concat(this._listeners['all'] || []);\n        if (EventEmitter.debugCallback)\n            EventEmitter.debugCallback(this.constructor.name, this.name, eventName, args, events);\n        var event, a, len = events.length, index;\n        var calls = [];\n        for (var i = 0, ii = events.length; i < ii; i++) {\n            event = events[i];\n            a = args;\n            if (event.name == 'all') {\n                a = [eventName].concat(args);\n                callFunc([event], a);\n            }\n            else {\n                calls.push(event);\n            }\n            if (event.once === true) {\n                index = this._listeners[event.name].indexOf(event);\n                this._listeners[event.name].splice(index, 1);\n            }\n        }\n        if (calls.length)\n            this._executeListener(calls, args);\n        return this;\n    };\n    EventEmitter.prototype._executeListener = function (func, args) {\n        var executor = callFunc;\n        if (this.constructor.executeListenerFunction) {\n            executor = this.constructor.executeListenerFunction;\n        }\n        executor(func, args);\n    };\n    EventEmitter.prototype.listenTo = function (obj, event, fn, ctx, once) {\n        if (once === void 0) { once = false; }\n        var listeningTo, id, meth;\n        listeningTo = this._listeningTo || (this._listeningTo = {});\n        id = obj.listenId || (obj.listenId = getID());\n        listeningTo[id] = obj;\n        meth = once ? 'once' : 'on';\n        obj[meth](event, fn, this);\n        return this;\n    };\n    EventEmitter.prototype.listenToOnce = function (obj, event, fn, ctx) {\n        return this.listenTo(obj, event, fn, ctx, true);\n    };\n    EventEmitter.prototype.stopListening = function (obj, event, callback) {\n        var listeningTo = this._listeningTo;\n        if (!listeningTo)\n            return this;\n        var remove = !event && !callback;\n        if (!callback && typeof event === 'object')\n            callback = this;\n        if (obj)\n            (listeningTo = {})[obj.listenId] = obj;\n        for (var id in listeningTo) {\n            obj = listeningTo[id];\n            obj.off(event, callback, this);\n            if (remove || !Object.keys(obj.listeners).length)\n                delete this._listeningTo[id];\n        }\n        return this;\n    };\n    EventEmitter.prototype.destroy = function () {\n        this.stopListening();\n        this.off();\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventsjs/lib/events.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require('./utils'));\n__export(require('./functions'));\n__export(require('./objects'));\n__export(require('./arrays'));\n__export(require('./promises'));\n__export(require('./strings'));\n__export(require('./map'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/index.js\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\nfunction isObject(obj) {\n    return obj === Object(obj);\n}\nexports.isObject = isObject;\nfunction isString(a) {\n    return typeof a === 'function';\n}\nexports.isString = isString;\nfunction isNumber(a) {\n    return typeof a === 'number';\n}\nexports.isNumber = isNumber;\nfunction isRegExp(a) {\n    return a && a instanceof RegExp;\n}\nexports.isRegExp = isRegExp;\nfunction isDate(a) {\n    return a && a instanceof Date;\n}\nexports.isDate = isDate;\nfunction isArray(a) {\n    return Array.isArray(a);\n}\nexports.isArray = isArray;\nfunction isFunction(a) {\n    return typeof a === 'function';\n}\nexports.isFunction = isFunction;\nvar idCounter = 0;\n/** Generate an unique id with an optional prefix\n * @param { string } prefix\n * @return { string }\n */\nfunction uniqueId(prefix = '') {\n    return prefix + (++idCounter);\n}\nexports.uniqueId = uniqueId;\nfunction equal(a, b) {\n    return eq(a, b, [], []);\n}\nexports.equal = equal;\nfunction getOption(option, objs) {\n    for (let o of objs) {\n        if (isObject(o) && o[option])\n            return o[option];\n    }\n    return null;\n}\nexports.getOption = getOption;\nexports.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener;\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f); };\n    }\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\nfunction xmlHttpRequest() {\n    var e;\n    if (window.hasOwnProperty('XMLHttpRequest')) {\n        return new XMLHttpRequest();\n    }\n    try {\n        return new ActiveXObject('msxml2.xmlhttp.6.0');\n    }\n    catch (_error) {\n        e = _error;\n    }\n    try {\n        return new ActiveXObject('msxml2.xmlhttp.3.0');\n    }\n    catch (_error) {\n        e = _error;\n    }\n    try {\n        return new ActiveXObject('msxml2.xmlhttp');\n    }\n    catch (_error) {\n        e = _error;\n    }\n    throw e;\n}\nexports.xmlHttpRequest = xmlHttpRequest;\nconst _has = Object.prototype.hasOwnProperty;\nfunction eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b)\n        return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null)\n        return a === b;\n    // Unwrap any wrapped objects.\n    //if (a instanceof _) a = a._wrapped;\n    //if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b))\n        return false;\n    switch (className) {\n        // Strings, numbers, dates, and booleans are compared by value.\n        case '[object String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return a == String(b);\n        case '[object Number]':\n            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n            // other numeric values.\n            return a !== +a ? b !== +b : (a === 0 ? 1 / a === 1 / b : a === +b);\n        case '[object Date]':\n        case '[object Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a == +b;\n        // RegExps are compared by their source patterns and flags.\n        case '[object RegExp]':\n            return a.source == b.source &&\n                a.global == b.global &&\n                a.multiline == b.multiline &&\n                a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object')\n        return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] == a)\n            return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(typeof aCtor === 'function' && (aCtor instanceof aCtor) &&\n        typeof bCtor === 'function' && (bCtor instanceof bCtor))) {\n        return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className === '[object Array]') {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        size = a.length;\n        result = size === b.length;\n        if (result) {\n            // Deep compare the contents, ignoring non-numeric properties.\n            while (size--) {\n                if (!(result = eq(a[size], b[size], aStack, bStack)))\n                    break;\n            }\n        }\n    }\n    else {\n        // Deep compare objects.\n        for (var key in a) {\n            if (_has.call(a, key)) {\n                // Count the expected number of properties.\n                size++;\n                // Deep compare each member.\n                if (!(result = _has.call(b, key) && eq(a[key], b[key], aStack, bStack)))\n                    break;\n            }\n        }\n        // Ensure that both objects contain the same number of properties.\n        if (result) {\n            for (key in b) {\n                if (_has.call(b, key) && !(size--))\n                    break;\n            }\n            result = !size;\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n}\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/utils.js\n ** module id = 8\n ** module chunks = 0\n **/","\"use strict\";\nconst arrays_1 = require('./arrays');\nconst strings_1 = require('./strings');\nconst objects_1 = require('./objects');\nconst nativeBind = Function.prototype.bind;\nfunction proxy(from, to, fns) {\n    if (!Array.isArray(fns))\n        fns = [fns];\n    fns.forEach(function (fn) {\n        if (typeof to[fn] === 'function') {\n            from[fn] = bind(to[fn], to);\n        }\n    });\n}\nexports.proxy = proxy;\nfunction bind(method, context, ...args) {\n    if (typeof method !== 'function')\n        throw new Error('method not at function');\n    if (nativeBind != null)\n        return nativeBind.call(method, context, ...args);\n    args = args || [];\n    let fnoop = function () { };\n    let fBound = function () {\n        let ctx = this instanceof fnoop ? this : context;\n        return callFunc(method, ctx, args.concat(arrays_1.slice(arguments)));\n    };\n    fnoop.prototype = this.prototype;\n    fBound.prototype = new fnoop();\n    return fBound;\n}\nexports.bind = bind;\nfunction callFunc(fn, ctx, args = []) {\n    switch (args.length) {\n        case 0:\n            return fn.call(ctx);\n        case 1:\n            return fn.call(ctx, args[0]);\n        case 2:\n            return fn.call(ctx, args[0], args[1]);\n        case 3:\n            return fn.call(ctx, args[0], args[1], args[2]);\n        case 4:\n            return fn.call(ctx, args[0], args[1], args[2], args[3]);\n        case 5:\n            return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);\n        default:\n            return fn.apply(ctx, args);\n    }\n}\nexports.callFunc = callFunc;\nfunction triggerMethodOn(obj, eventName, args) {\n    let ev = strings_1.camelcase(\"on-\" + eventName.replace(':', '-'));\n    if (obj[ev] && typeof obj[ev] === 'function') {\n        callFunc(obj[ev], obj, args);\n    }\n    if (typeof obj.trigger === 'function') {\n        args = [eventName].concat(args);\n        callFunc(obj.trigger, obj, args);\n    }\n}\nexports.triggerMethodOn = triggerMethodOn;\nfunction inherits(parent, protoProps, staticProps) {\n    var child;\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && objects_1.has(protoProps, 'constructor')) {\n        child = protoProps.constructor;\n    }\n    else {\n        child = function () { return parent.apply(this, arguments); };\n    }\n    // Add static properties to the constructor function, if supplied.\n    objects_1.extend(child, parent, staticProps);\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function () { this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps)\n        objects_1.extend(child.prototype, protoProps);\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n    return child;\n}\nexports.inherits = inherits;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/functions.js\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\n/*class KeyValuePair<K, V> {\n    key: K;\n    value: V;\n    constructor(key: K, value: V) {\n        this.key = key;\n        this.value = value;\n    }\n}\nexport class Map<K, V> { // class MapDDD<K,V> implements Map\n    // -------------- Fields -----------------------\n    private keyAndValues: Array<KeyValuePair<K, V>>;\n    // ---------------------------------------------\n    constructor() {\n        this.keyAndValues = [];\n    }\n    // --- Public Methods ---\n    getKeysOfValue(value: V) {\n        var keysToReturn: Array<K> = [];\n        var valueToFind = value;\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            if (value.value === valueToFind) {\n                keysToReturn.push(value.key);\n            }\n        });\n        return keysToReturn;\n    }\n\n    // Standard:\n    clear(): void {\n        this.keyAndValues = [];\n    }\n    delete(key: K): boolean {\n        var found = false;\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            if (found) return;\n            if (key === value.key) {\n                array = array.slice(0, index).concat(array.slice(index + 1));\n                found = true;\n            }\n        });\n        return found;\n    }\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            callbackfn.apply(thisArg, [value.value, value.key, this]);\n        }, this);\n    }\n    get(key: K): V {\n        var valueToReturn: V = undefined;\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            if (valueToReturn !== undefined) return;\n            if (key === value.key) {\n                valueToReturn = value.value;\n            }\n        });\n        return valueToReturn;\n    }\n    has(key: K): boolean {\n        var found = false;\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            if (found) return;\n            if (key === value.key) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    set(key: K, value: V): Map<K, V> {\n        var found = false;\n        var valueToSet = value;\n        this.keyAndValues.forEach(function (value: KeyValuePair<K, V>, index: number, array: KeyValuePair<K, V>[]): void {\n            if (found) return;\n            if (key === value.key) {\n                found = true;\n                value.value = valueToSet;\n            }\n        });\n        if (!found) {\n            this.keyAndValues.push(new KeyValuePair<K, V>(key, valueToSet));\n        }\n        return this;\n    }\n    // ----------------------\n\n    // Getters:\n    // Standard:\n    get size() {\n        return this.keyAndValues.length;\n    }\n}*/\n// Return a new array with duplicates removed\nfunction unique(array) {\n    let seen = new Map();\n    return array.filter(function (e, i) {\n        if (seen.has(e))\n            return false;\n        /*for (i += 1; i < array.length; i += 1) {\n          if (equal(e, array[i])) {\n            return false;\n          }\n        }*/\n        seen.set(e, true);\n        return true;\n    });\n}\nexports.unique = unique;\nfunction any(array, predicate) {\n    for (let i = 0, ii = array.length; i < ii; i++) {\n        if (predicate(array[i]))\n            return true;\n    }\n    return false;\n}\nexports.any = any;\nfunction indexOf(array, item) {\n    for (var i = 0, len = array.length; i < len; i++)\n        if (array[i] === item)\n            return i;\n    return -1;\n}\nexports.indexOf = indexOf;\nfunction find(array, callback, ctx) {\n    let v;\n    for (let i = 0, ii = array.length; i < ii; i++) {\n        if (callback.call(ctx, array[i]))\n            return array[i];\n    }\n    return null;\n}\nexports.find = find;\nfunction slice(array, begin, end) {\n    return Array.prototype.slice.call(array, begin, end);\n}\nexports.slice = slice;\nfunction flatten(arr) {\n    return arr.reduce(function (flat, toFlatten) {\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\n    }, []);\n}\nexports.flatten = flatten;\nfunction sortBy(obj, value, context) {\n    var iterator = typeof value === 'function' ? value : function (obj) { return obj[value]; };\n    return obj\n        .map(function (value, index, list) {\n        return {\n            value: value,\n            index: index,\n            criteria: iterator.call(context, value, index, list)\n        };\n    })\n        .sort(function (left, right) {\n        let a = left.criteria, b = right.criteria;\n        if (a !== b) {\n            if (a > b || a === void 0)\n                return 1;\n            if (a < b || b === void 0)\n                return -1;\n        }\n        return left.index - right.index;\n    })\n        .map(function (item) {\n        return item.value;\n    });\n}\nexports.sortBy = sortBy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/arrays.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\nfunction camelcase(input) {\n    return input.toLowerCase().replace(/-(.)/g, function (match, group1) {\n        return group1.toUpperCase();\n    });\n}\nexports.camelcase = camelcase;\n;\nfunction truncate(str, length) {\n    let n = str.substring(0, Math.min(length, str.length));\n    return n + (n.length == str.length ? '' : '...');\n}\nexports.truncate = truncate;\nfunction humanFileSize(bytes, si = false) {\n    var thresh = si ? 1000 : 1024;\n    if (Math.abs(bytes) < thresh) {\n        return bytes + ' B';\n    }\n    var units = si\n        ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];\n    var u = -1;\n    do {\n        bytes /= thresh;\n        ++u;\n    } while (Math.abs(bytes) >= thresh && u < units.length - 1);\n    return bytes.toFixed(1) + ' ' + units[u];\n}\nexports.humanFileSize = humanFileSize;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/strings.js\n ** module id = 11\n ** module chunks = 0\n **/","\"use strict\";\nconst utils_1 = require('./utils');\nconst arrays_1 = require('./arrays');\n/**\n * Takes a nested object and returns a shallow object keyed with the path names\n * e.g. { \"level1.level2\": \"value\" }\n *\n * @param  {Object}      Nested object e.g. { level1: { level2: 'value' } }\n * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }\n */\nfunction objToPaths(obj, separator = \".\") {\n    var ret = {};\n    for (var key in obj) {\n        var val = obj[key];\n        if (val && (val.constructor === Object || val.constructor === Array) && !isEmpty(val)) {\n            //Recursion for embedded objects\n            var obj2 = objToPaths(val);\n            for (var key2 in obj2) {\n                var val2 = obj2[key2];\n                ret[key + separator + key2] = val2;\n            }\n        }\n        else {\n            ret[key] = val;\n        }\n    }\n    return ret;\n}\nexports.objToPaths = objToPaths;\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\nexports.isEmpty = isEmpty;\nfunction extend(obj, ...args) {\n    if (!utils_1.isObject(obj))\n        return obj;\n    let o, k;\n    for (o of args) {\n        if (!utils_1.isObject(o))\n            continue;\n        for (k in o) {\n            if (has(o, k))\n                obj[k] = o[k];\n        }\n    }\n    return obj;\n}\nexports.extend = extend;\nconst nativeAssign = Object.assign;\nfunction assign(target, ...args) {\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert first argument to object');\n    }\n    if (nativeAssign)\n        return nativeAssign(target, ...args);\n    var to = Object(target);\n    for (let i = 0, ii = args.length; i < ii; i++) {\n        var nextSource = args[i];\n        if (nextSource === undefined || nextSource === null) {\n            continue;\n        }\n        nextSource = Object(nextSource);\n        var keysArray = Object.keys(Object(nextSource));\n        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n            var nextKey = keysArray[nextIndex];\n            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n            if (desc !== undefined && desc.enumerable) {\n                to[nextKey] = nextSource[nextKey];\n            }\n        }\n    }\n    return to;\n}\nexports.assign = assign;\nconst _has = Object.prototype.hasOwnProperty;\nfunction has(obj, prop) {\n    return _has.call(obj, prop);\n}\nexports.has = has;\nfunction pick(obj, props) {\n    let out = {}, prop;\n    for (prop of props) {\n        if (has(obj, prop))\n            out[prop] = obj[prop];\n    }\n    return out;\n}\nexports.pick = pick;\nfunction omit(obj, props) {\n    let out = {};\n    for (let key in obj) {\n        if (!!~props.indexOf(key))\n            continue;\n        out[key] = obj[key];\n    }\n    return out;\n}\nexports.omit = omit;\nfunction result(obj, prop, ctx, args) {\n    let ret = obj[prop];\n    return (typeof ret === 'function') ? ret.appl(ctx, args || []) : ret;\n}\nexports.result = result;\nfunction values(obj) {\n    let output = [];\n    for (let k in obj)\n        if (has(obj, k)) {\n            output.push(obj[k]);\n        }\n    return output;\n}\nexports.values = values;\nfunction intersectionObjects(a, b, predicate) {\n    var results = [], aElement, existsInB;\n    for (let i = 0, ii = a.length; i < ii; i++) {\n        aElement = a[i];\n        existsInB = arrays_1.any(b, function (bElement) { return predicate(bElement, aElement); });\n        if (existsInB) {\n            results.push(aElement);\n        }\n    }\n    return results;\n}\nfunction intersection(results, ...args) {\n    var lastArgument = args[args.length - 1];\n    var arrayCount = args.length;\n    var areEqualFunction = utils_1.equal;\n    if (typeof lastArgument === \"function\") {\n        areEqualFunction = lastArgument;\n        arrayCount--;\n    }\n    for (var i = 0; i < arrayCount; i++) {\n        var array = args[i];\n        results = intersectionObjects(results, array, areEqualFunction);\n        if (results.length === 0)\n            break;\n    }\n    return results;\n}\nexports.intersection = intersection;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/objects.js\n ** module id = 12\n ** module chunks = 0\n **/","\"use strict\";\nconst arrays_1 = require('./arrays');\nconst utils_1 = require('./utils');\nexports.Promise = (typeof window === 'undefined') ? global.Promise : window.Promise;\n// Promises\nfunction isPromise(obj) {\n    return obj && typeof obj.then === 'function';\n}\nexports.isPromise = isPromise;\nfunction toPromise(obj) {\n    /* jshint validthis:true */\n    if (!obj) {\n        return obj;\n    }\n    if (isPromise(obj)) {\n        return obj;\n    }\n    if (utils_1.isFunction(obj)) {\n        return thunkToPromise.call(this, obj);\n    }\n    if (Array.isArray(obj)) {\n        return arrayToPromise.call(this, obj);\n    }\n    if (utils_1.isObject(obj)) {\n        return objectToPromise.call(this, obj);\n    }\n    return exports.Promise.resolve(obj);\n}\nexports.toPromise = toPromise;\n/**\n * Convert a thunk to a promise.\n *\n * @param {Function}\n * @return {Promise}\n * @api private\n */\nfunction thunkToPromise(fn) {\n    /* jshint validthis:true */\n    var ctx = this;\n    return new exports.Promise(function (resolve, reject) {\n        fn.call(ctx, function (err, res) {\n            if (err)\n                return reject(err);\n            if (arguments.length > 2)\n                res = arrays_1.slice(arguments, 1);\n            resolve(res);\n        });\n    });\n}\nexports.thunkToPromise = thunkToPromise;\n/**\n * Convert an array of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Array} obj\n * @return {Promise}\n * @api private\n */\nfunction arrayToPromise(obj) {\n    return exports.Promise.all(obj.map(toPromise, this));\n}\nexports.arrayToPromise = arrayToPromise;\n/**\n * Convert an object of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Object} obj\n * @return {Promise}\n * @api private\n */\nfunction objectToPromise(obj) {\n    var results = new obj.constructor();\n    var keys = Object.keys(obj);\n    var promises = [];\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var promise = toPromise.call(this, obj[key]);\n        if (promise && isPromise(promise))\n            defer(promise, key);\n        else\n            results[key] = obj[key];\n    }\n    return exports.Promise.all(promises).then(function () {\n        return results;\n    });\n    function defer(promise, key) {\n        // predefine the key in the result\n        results[key] = undefined;\n        promises.push(promise.then(function (res) {\n            results[key] = res;\n        }));\n    }\n}\nexports.objectToPromise = objectToPromise;\nfunction deferred() {\n    let ret = {};\n    ret.promise = new exports.Promise(function (resolve, reject) {\n        ret.resolve = resolve;\n        ret.reject = reject;\n        ret.done = function (err, result) { if (err)\n            return reject(err);\n        else\n            resolve(result); };\n    });\n    return ret;\n}\nexports.deferred = deferred;\n;\nfunction callback(promise, callback, ctx) {\n    promise.then(function (result) {\n        callback.call(ctx, null, result);\n    }).catch(function (err) {\n        callback.call(ctx, err);\n    });\n}\nexports.callback = callback;\nfunction delay(timeout) {\n    let defer = deferred();\n    timeout == null ? utils_1.nextTick(defer.resolve) : setTimeout(defer.resolve, timeout);\n    return defer.promise;\n}\nexports.delay = delay;\n;\nfunction eachAsync(array, iterator, context, accumulate = false) {\n    return mapAsync(array, iterator, context, accumulate)\n        .then(function () { return void 0; });\n}\nexports.eachAsync = eachAsync;\nfunction mapAsync(array, iterator, context, accumulate = false) {\n    return new exports.Promise(function (resolve, reject) {\n        let i = 0, len = array.length, errors = [], results = [];\n        function next(err, result) {\n            if (err && !accumulate)\n                return reject(err);\n            if (err)\n                errors.push(err);\n            if (i === len)\n                return errors.length ? reject(arrays_1.flatten(errors)) : resolve(results);\n            let ret = iterator.call(context, array[i++]);\n            if (isPromise(ret)) {\n                ret.then(function (r) { results.push(r); next(null, r); }, next);\n            }\n            else if (ret instanceof Error) {\n                next(ret);\n            }\n            else {\n                next(null);\n            }\n        }\n        next(null);\n    });\n}\nexports.mapAsync = mapAsync;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/promises.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\nvar self = global || Window;\nconst iterable = 'Symbol' in self && 'iterator' in Symbol;\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n    var iterator = {\n        next: function () {\n            var value = items.shift();\n            return { done: value === undefined, value: value };\n        }\n    };\n    if (iterable) {\n        iterator[Symbol.iterator] = function () {\n            return iterator;\n        };\n    }\n    return iterator;\n}\nclass KeyValuePair {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\nclass MapShim {\n    // ---------------------------------------------\n    constructor() {\n        this.keyAndValues = [];\n    }\n    // --- Public Methods ---\n    getKeysOfValue(value) {\n        var keysToReturn = [];\n        var valueToFind = value;\n        this.keyAndValues.forEach(function (value, index, array) {\n            if (value.value === valueToFind) {\n                keysToReturn.push(value.key);\n            }\n        });\n        return keysToReturn;\n    }\n    // Standard:\n    clear() {\n        this.keyAndValues = [];\n    }\n    delete(key) {\n        var found = false;\n        this.keyAndValues.forEach(function (value, index, array) {\n            if (found)\n                return;\n            if (key === value.key) {\n                array = array.slice(0, index).concat(array.slice(index + 1));\n                found = true;\n            }\n        });\n        return found;\n    }\n    forEach(callbackfn, thisArg) {\n        this.keyAndValues.forEach(function (value, index, array) {\n            callbackfn.apply(thisArg, [value.value, value.key, this]);\n        }, this);\n    }\n    get(key) {\n        var valueToReturn = undefined;\n        this.keyAndValues.forEach(function (value, index, array) {\n            if (valueToReturn !== undefined)\n                return;\n            if (key === value.key) {\n                valueToReturn = value.value;\n            }\n        });\n        return valueToReturn;\n    }\n    has(key) {\n        var found = false;\n        this.keyAndValues.forEach(function (value, index, array) {\n            if (found)\n                return;\n            if (key === value.key) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    set(key, value) {\n        var found = false;\n        var valueToSet = value;\n        this.keyAndValues.forEach(function (value, index, array) {\n            if (found)\n                return;\n            if (key === value.key) {\n                found = true;\n                value.value = valueToSet;\n            }\n        });\n        if (!found) {\n            this.keyAndValues.push(new KeyValuePair(key, valueToSet));\n        }\n        return this;\n    }\n    keys() {\n        var items = [];\n        this.forEach(function (value, name) { items.push(name); });\n        return iteratorFor(items);\n    }\n    values() {\n        var items = [];\n        this.forEach(function (value) { items.push(value); });\n        return iteratorFor(items);\n    }\n    entries() {\n        var items = [];\n        this.forEach(function (value, name) { items.push([name, value]); });\n        return iteratorFor(items);\n    }\n    // ----------------------\n    // Getters:\n    // Standard:\n    get size() {\n        return this.keyAndValues.length;\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n}\nif (!global.Map) {\n    global.Map = MapShim;\n}\nexports.Map = global.Map;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/orange/map.js\n ** module id = 14\n ** module chunks = 0\n **/","\"use strict\";\nconst kUIRegExp = /@ui.([a-zA-Z_\\-\\$#]+)/i;\nfunction normalizeUIKeys(obj, uimap) {\n    /*jshint -W030 */\n    let o = {}, k, v, ms, sel, ui;\n    for (k in obj) {\n        v = obj[k];\n        if ((ms = kUIRegExp.exec(k)) !== null) {\n            ui = ms[1], sel = uimap[ui];\n            if (sel != null) {\n                k = k.replace(ms[0], sel);\n            }\n        }\n        o[k] = v;\n    }\n    return o;\n}\nexports.normalizeUIKeys = normalizeUIKeys;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util.js\n ** module id = 15\n ** module chunks = 0\n **/","\"use strict\";\nconst debug = require('debug')('views:region');\nconst object_1 = require('./object');\nconst orange_1 = require('orange');\n/** Region  */\nclass Region extends object_1.BaseObject {\n    /**\n     * Regions manage a view\n     * @param {Object} options\n     * @param {HTMLElement} options.el  A Html element\n     * @constructor Region\n     * @extends BaseObject\n     * @inheritdoc\n     */\n    constructor(options) {\n        super();\n        this.options = options;\n        this._el = this.getOption('el');\n    }\n    get view() {\n        return this._view;\n    }\n    set view(view) {\n        this.show(view);\n    }\n    get el() {\n        return this._el;\n    }\n    /**\n     * Build region from a definition\n     * @param {Object|String|Region} def The description of the region\n     * @return {Region}\n     */\n    static buildRegion(def, context = null) {\n        if (def instanceof Region) {\n            return def;\n        }\n        else if (typeof def === 'string') {\n            return buildBySelector(def, Region, context);\n        }\n        else {\n            return buildByObject(def, context);\n        }\n    }\n    /**\n   * Show a view in the region.\n   * This will destroy or remove any existing views.\n   * @param  {View} view    The view to Show\n   * @return {Region}       this for chaining.\n   */\n    show(view, options) {\n        let diff = view !== this._view;\n        if (diff) {\n            // Remove any containing views\n            this.empty();\n            // If the view is destroyed be others\n            view.once('destroy', this.empty, this);\n            debug('%s render view %s', this, view);\n            view.render();\n            orange_1.triggerMethodOn(view, 'before:show');\n            debug('%s attaching view: %s', this, view);\n            this._attachHtml(view);\n            orange_1.triggerMethodOn(view, 'show');\n            this._view = view;\n        }\n        return this;\n    }\n    /**\n     * Destroy the region, this will remove any views, but not the containing element\n     * @return {Region} this for chaining\n     */\n    destroy() {\n        this.empty();\n        super.destroy();\n    }\n    /**\n     * Empty the region. This will destroy any existing view.\n     * @return {Region} this for chaining;\n     */\n    empty() {\n        if (!this._view)\n            return;\n        let view = this._view;\n        view.off('destroy', this.empty, this);\n        this.trigger('before:empty', view);\n        this._destroyView();\n        this.trigger('empty', view);\n        delete this._view;\n        return this;\n    }\n    /**\n     * Attach the view element to the regions element\n     * @param {View} view\n     * @private\n     *\n     */\n    _attachHtml(view) {\n        this._el.innerHTML = '';\n        this._el.appendChild(view.el);\n    }\n    _destroyView() {\n        let view = this._view;\n        if ((view.destroy && typeof view.destroy === 'function') && !view.isDestroyed) {\n            view.destroy();\n        }\n        else if (view.remove && typeof view.remove === 'function') {\n            view.remove();\n        }\n        this._el.innerHTML = '';\n    }\n}\nexports.Region = Region;\nfunction buildByObject(object = {}, context) {\n    if (!object.selector)\n        throw new Error('No selector specified: ' + object);\n    return buildBySelector(object.selector, object.regionClass || Region, context);\n}\nfunction buildBySelector(selector, Klass = Region, context) {\n    context = context || document;\n    var el = context.querySelector(selector);\n    if (!el)\n        throw new Error('selector must exist in the dom');\n    return new Klass({\n        el: el\n    });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/region.js\n ** module id = 16\n ** module chunks = 0\n **/","/* global BaseClass, __has */\n\"use strict\";\nconst object_1 = require('./object');\nconst region_1 = require('./region');\nconst utils = require('orange');\nclass RegionManager extends object_1.BaseObject {\n    /** Region manager\n     * @extends BaseObject\n     */\n    constructor() {\n        super();\n        this._regions = {};\n    }\n    /**\n     * Regions\n     * @type {string:Region}\n     */\n    get regions() {\n        return this._regions;\n    }\n    /**\n      * Add one or more regions to the region manager\n      * @param {Object} regions\n      */\n    addRegions(regions) {\n        let def, out = {}, keys = Object.keys(regions);\n        keys.forEach(function (k) {\n            def = regions[k];\n            out[k] = this.addRegion(k, def);\n        }, this);\n        return out;\n    }\n    /**\n     * Add a region to the RegionManager\n     * @param {String} name   The name of the regions\n     * @param {String|Object|Region|HTMLElement} def The region to associate with the name and the RegionManager\n     */\n    addRegion(name, def) {\n        let region = region_1.Region.buildRegion(def);\n        this._setRegion(name, region);\n        return region;\n    }\n    /**\n     * Remove one or more regions from the manager\n     * @param {...name} name A array of region names\n     */\n    removeRegion(names) {\n        if (typeof names === 'string') {\n            names = [names];\n        }\n        names.forEach(function (name) {\n            if (utils.has(this.regions, name)) {\n                let region = this.regions[name];\n                region.destroy();\n                this._unsetRegion(name);\n            }\n        }, this);\n    }\n    /**\n     * Destroy the regionmanager\n     */\n    destroy() {\n        this.removeRegions();\n        super.destroy();\n    }\n    /**\n     * Remove all regions from the manager\n     */\n    removeRegions() {\n        utils.callFunc(this.removeRegion, this, Object.keys(this._regions));\n    }\n    /**\n     * @private\n     */\n    _setRegion(name, region) {\n        if (this._regions[name]) {\n            this._regions[name].destroy();\n        }\n        this._regions[name] = region;\n    }\n    /**\n     * @private\n     */\n    _unsetRegion(name) {\n        delete this._regions[name];\n    }\n}\nexports.RegionManager = RegionManager;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/region-manager.js\n ** module id = 17\n ** module chunks = 0\n **/","\"use strict\";\n/*global View, RegionManager, Region*/\nconst view_1 = require('./view');\nconst region_manager_1 = require('./region-manager');\nconst orange_1 = require('orange');\nconst region_1 = require('./region');\nclass LayoutView extends view_1.View {\n    /**\n     * LayoutView\n     * @param {Object} options options\n     * @constructor LayoutView\n     * @extends TemplateView\n     */\n    constructor(options) {\n        super(options);\n        // Set region manager\n        this._regionManager = new region_manager_1.RegionManager();\n        orange_1.proxy(this, this._regionManager, ['removeRegion', 'removeRegions']);\n        this._regions = this.getOption('regions', options || {});\n    }\n    get regions() {\n        return this._regionManager.regions;\n    }\n    render(options) {\n        this.triggerMethod('before:render');\n        super.render({ silent: true });\n        this.addRegion(this._regions || {});\n        this.triggerMethod('render');\n        return this;\n    }\n    /**\n     * Add one or more regions to the view\n     * @param {string|RegionMap} name\n     * @param {Object|string|HTMLElement} def\n     */\n    addRegion(name, def) {\n        let regions = {};\n        if (typeof name === 'string') {\n            if (def == null)\n                throw new Error('add region');\n            regions[name] = def;\n        }\n        else {\n            regions = name;\n        }\n        for (let k in regions) {\n            let region = region_1.Region.buildRegion(regions[k], this.el);\n            this._regionManager.addRegion(k, region);\n        }\n    }\n    /**\n     * Delete one or more regions from the the layoutview\n     * @param {string|Array<string>} name\n     */\n    removeRegion(name) {\n        this._regionManager.removeRegion(name);\n    }\n    destroy() {\n        super.destroy();\n        this._regionManager.destroy();\n    }\n}\nexports.LayoutView = LayoutView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/layout-view.js\n ** module id = 18\n ** module chunks = 0\n **/","\"use strict\";\nconst debug = require('debug')('views:view');\nconst baseview_1 = require('./baseview');\nconst orange_1 = require('orange');\nclass View extends baseview_1.BaseView {\n    /**\n     * DataView\n     * @param {DataViewOptions} options\n     * @extends TemplateView\n     */\n    constructor(options = {}) {\n        super(options);\n        orange_1.extend(this, orange_1.pick(options, ['model', 'collection', 'template']));\n    }\n    get model() { return this._model; }\n    set model(model) {\n        this.setModel(model);\n    }\n    get collection() { return this._collection; }\n    set collection(collection) {\n        this.setCollection(collection);\n    }\n    setModel(model) {\n        if (this._model === model)\n            return this;\n        this.triggerMethod('before:model', this._model, model);\n        if (this.model) {\n            debug('stop listening on model uid: %s', this.model.uid);\n            this.stopListening(this._model);\n        }\n        debug('%s set model uid: %s', this, model.uid);\n        this._model = model;\n        this.triggerMethod('model', model);\n        return this;\n    }\n    setCollection(collection) {\n        if (this._collection === collection)\n            return this;\n        this.triggerMethod('before:collection', this._collection, collection);\n        if (this._collection) {\n            debug('%s stop listening on collection', this);\n            this.stopListening(this._collection);\n        }\n        this._collection = collection;\n        this.triggerMethod('collection', collection);\n        return this;\n    }\n    getTemplateData() {\n        return this.model ?\n            typeof this.model.toJSON === 'function' ?\n                this.model.toJSON() : this.model : {};\n    }\n    render(options = {}) {\n        debug('%s render', this);\n        if (!options.silent)\n            this.triggerMethod('before:render');\n        this.undelegateEvents();\n        this.renderTemplate(this.getTemplateData());\n        this.delegateEvents();\n        if (!options.silent)\n            this.triggerMethod('render');\n        return this;\n    }\n    delegateEvents(events) {\n        events = events || orange_1.result(this, 'events');\n        let { c, e, m } = this._filterEvents(events);\n        super.delegateEvents(e);\n        this._delegateDataEvents(m, c);\n        return this;\n    }\n    undelegateEvents() {\n        this._undelegateDataEvents();\n        super.undelegateEvents();\n        return this;\n    }\n    renderTemplate(data) {\n        let template = this.getOption('template');\n        if (typeof template === 'function') {\n            debug('%s render template function', this);\n            template = template.call(this, data);\n        }\n        if (template && typeof template === 'string') {\n            debug('%s attach template: %s', this, template);\n            this.attachTemplate(template);\n        }\n    }\n    attachTemplate(template) {\n        //this.undelegateEvents();\n        this.el.innerHTML = template;\n        //this.delegateEvents();\n    }\n    _delegateDataEvents(model, collection) {\n        this._dataEvents = {};\n        let fn = (item, ev) => {\n            if (!this[item])\n                return {};\n            let out = {}, k, f;\n            for (k in ev) {\n                f = orange_1.bind(ev[k], this);\n                this[item].on(k, f);\n                out[item + \":\" + k] = f;\n            }\n            return out;\n        };\n        orange_1.extend(this._dataEvents, fn('model', model), fn('collection', collection));\n    }\n    _undelegateDataEvents() {\n        if (!this._dataEvents)\n            return;\n        let k, v;\n        for (k in this._dataEvents) {\n            v = this._dataEvents[k];\n            let [item, ev] = k.split(':');\n            if (!this[item])\n                continue;\n            this[item].off(ev, v);\n        }\n        delete this._dataEvents;\n    }\n    _filterEvents(obj) {\n        /*jshint -W030 */\n        let c = {}, m = {}, e = {}, k, v;\n        for (k in obj) {\n            let [ev, t] = k.split(' ');\n            ev = ev.trim(), t = t ? t.trim() : \"\", v = obj[k];\n            if (t === 'collection') {\n                c[ev] = v;\n            }\n            else if (t === 'model') {\n                m[ev] = v;\n            }\n            else {\n                e[k] = v;\n            }\n        }\n        return { c: c, m: m, e: e };\n    }\n}\nexports.View = View;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/view.js\n ** module id = 19\n ** module chunks = 0\n **/","\"use strict\";\nconst debug = require('debug')('views:collectionview');\nconst view_1 = require('./view');\nconst orange_1 = require('orange');\nconst eventsjs_1 = require('eventsjs');\nclass Buffer {\n    constructor() {\n        this.children = [];\n        this.buffer = document.createDocumentFragment();\n    }\n    append(view) {\n        this.children.push(view);\n        this.buffer.appendChild(view.el);\n    }\n}\nclass CollectionView extends view_1.View {\n    /** CollectionView\n   * @extends DataView\n   * @param {DataViewOptions} options\n   */\n    constructor(options) {\n        super(options);\n        this._options = options || {};\n        this.children = [];\n        this.sort = (options && options.sort != null) ? options.sort : true;\n        if (typeof this.initialize === 'function') {\n            orange_1.callFunc(this.initialize, this, orange_1.slice(arguments));\n        }\n    }\n    /**\n   * Render the collection view and alle of the children\n   * @return {CollectionView}\n   *\n   */\n    render(options) {\n        this.destroyChildren();\n        this._destroyContainer();\n        super.render(options);\n        this._initContainer();\n        if (this.collection && this.collection.length) {\n            this.renderCollection();\n        }\n        else {\n            this.showEmptyView();\n        }\n        return this;\n    }\n    /**\n     * @protected\n     */\n    setCollection(collection) {\n        super.setCollection(collection);\n        this._delegateCollectionEvents();\n        return this;\n    }\n    renderCollection() {\n        this.destroyChildren();\n        if (this.collection.length !== 0) {\n            this.hideEmptyView();\n            this._startBuffering();\n            this._renderCollection();\n            this._stopBuffering();\n        }\n        else {\n            this.showEmptyView();\n        }\n    }\n    /**\n   * Returns a new instance of this.childView with attached model.\n   *\n   * @param {IModel} model\n   * @protected\n   */\n    getChildView(model) {\n        let ViewClass = this.getOption('childView') || view_1.View, options = this.getOption('childViewOptions') || {};\n        return new ViewClass(orange_1.extend({\n            model: model\n        }, options));\n    }\n    renderChildView(view, index) {\n        this.triggerMethod('before:render:child', view);\n        debug('%s render child: %s', this, view);\n        view.render();\n        this._attachHTML(view, index);\n        this.triggerMethod('render:child', view);\n    }\n    showEmptyView() {\n        let EmptyView = this.getOption('emptyView');\n        if (EmptyView == null)\n            return;\n        let view = new EmptyView();\n        this._emptyView = view;\n        this._container.appendChild(view.render().el);\n    }\n    hideEmptyView() {\n        if (!this._emptyView)\n            return;\n        this._emptyView.destroy();\n        this._emptyView.remove();\n        this._emptyView = void 0;\n    }\n    destroyChildren() {\n        if (this._container) {\n            this._container.innerHTML = '';\n        }\n        if (this.children.length === 0)\n            return;\n        this.children.forEach(this.removeChildView, this);\n        this.children = [];\n    }\n    removeChildView(view) {\n        if (!view)\n            return;\n        if (typeof view.destroy === 'function') {\n            debug('%s destroy child view: %s', this, view);\n            view.destroy();\n        }\n        else if (typeof view.remove === 'function') {\n            debug('%s remove child view: %s', this, view);\n            view.remove();\n        }\n        this.stopListening(view);\n        this.children.splice(this.children.indexOf(view), 1);\n        if (this.children.length === 0) {\n            this.showEmptyView();\n        }\n        this._updateIndexes(view, false);\n    }\n    /**\n   * Destroy the collection view and all of it's children\n   * @see JaffaMVC.View\n   * @return {JaffaMVC.View}\n   */\n    destroy() {\n        this.triggerMethod('before:destroy:children');\n        this.destroyChildren();\n        this.triggerMethod('destroy:children');\n        this.hideEmptyView();\n        //if (this._emptyView) this.hideEmptyView();\n        return super.destroy();\n    }\n    _renderCollection() {\n        this.triggerMethod('before:render:collection');\n        this.collection.forEach((model, index) => {\n            let view = this.getChildView(model);\n            this._appendChild(view, index);\n        });\n        this.triggerMethod('render:collection');\n    }\n    /**\n   * Append childview to the container\n   * @private\n   * @param {IDataView} view\n   * @param {Number} index\n   */\n    _appendChild(view, index) {\n        this._updateIndexes(view, true, index);\n        this._proxyChildViewEvents(view);\n        debug('%s append child %s at index: %s', this, view, index);\n        this.children.push(view);\n        this.hideEmptyView();\n        this.renderChildView(view, index);\n        this.triggerMethod('add:child', view);\n    }\n    /**\n   * Attach the childview's element to the CollectionView.\n   * When in buffer mode, the view is added to a documentfragment to optimize performance\n   * @param {View} view  A view\n   * @param {Number} index The index in which to insert the view\n   * @private\n   */\n    _attachHTML(view, index) {\n        if (this._buffer) {\n            debug(\"%s attach to buffer: %s\", this, view);\n            this._buffer.append(view);\n        }\n        else {\n            //if (this._isShown) {\n            //  utils.triggerMethodOn(view, 'before:show');\n            //}\n            if (!this._insertBefore(view, index)) {\n                this._insertAfter(view);\n            }\n        }\n    }\n    /**\n   * Proxy event froms childview to the collectionview\n   * @param {IView} view\n   * @private\n   */\n    _proxyChildViewEvents(view) {\n        let prefix = this.getOption('prefix') || 'childview';\n        this.listenTo(view, 'all', function () {\n            let args = orange_1.slice(arguments);\n            args[0] = prefix + ':' + args[0];\n            args.splice(1, 0, view);\n            orange_1.callFunc(this.triggerMethod, this, args);\n        });\n    }\n    _updateIndexes(view, increment, index) {\n        if (!this.sort)\n            return;\n        if (increment)\n            view._index = index;\n        this.children.forEach(function (lView) {\n            if (lView._index >= view._index) {\n                increment ? lView._index++ : lView._index--;\n            }\n        });\n    }\n    _startBuffering() {\n        debug(\"%s initializing buffer\", this);\n        this._buffer = new Buffer();\n    }\n    _stopBuffering() {\n        debug('%s appending buffer to container', this);\n        this._container.appendChild(this._buffer.buffer);\n        delete this._buffer;\n    }\n    _initContainer() {\n        debug(\"%s init container\", this);\n        var container = this.getOption('childViewContainer');\n        if (container) {\n            container = this.$(container)[0];\n        }\n        else {\n            container = this.el;\n        }\n        this._container = container;\n    }\n    _destroyContainer() {\n        if (this._container)\n            delete this._container;\n    }\n    /**\n     * Internal method. Check whether we need to insert the view into\n   * the correct position.\n     * @param  {IView} childView [description]\n     * @param  {number} index     [description]\n     * @return {boolean}           [description]\n     */\n    _insertBefore(childView, index) {\n        let currentView;\n        let findPosition = this.sort && (index < this.children.length - 1);\n        if (findPosition) {\n            // Find the view after this one\n            currentView = orange_1.find(this.children, (view) => {\n                return view._index === index + 1;\n            });\n        }\n        if (currentView) {\n            debug('%s insert child %s before: %s', this, childView, currentView);\n            this._container.insertBefore(childView.el, currentView.el);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Internal method. Append a view to the end of the $el\n     * @private\n     */\n    _insertAfter(childView) {\n        debug('%s insert child %s ', this, childView);\n        this._container.appendChild(childView.el);\n    }\n    /**\n     * Delegate collection events\n     * @private\n     */\n    _delegateCollectionEvents() {\n        if (this.collection && eventsjs_1.isEventEmitter(this.collection)) {\n            this.listenTo(this.collection, 'add', this._onCollectionAdd);\n            this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n            this.listenTo(this.collection, 'reset', this.render);\n            if (this.sort)\n                this.listenTo(this.collection, 'sort', this._onCollectionSort);\n        }\n    }\n    // Event handlers\n    /**\n     * Called when a model is add to the collection\n     * @param {JaffaMVC.Model|Backbone.model} model Model\n     * @private\n     */\n    _onCollectionAdd(model) {\n        debug('%s received add event from collection %s', this, this.collection);\n        let view = this.getChildView(model);\n        let index = this.collection.indexOf(model);\n        this._appendChild(view, index);\n    }\n    /**\n     * Called when a model is removed from the collection\n     * @param {JaffaMVC.Model|Backbone.model} model Model\n     * @private\n     */\n    _onCollectionRemove(model) {\n        debug('%s received remove event from collection %s', this, this.collection);\n        let view = orange_1.find(this.children, function (view) {\n            return view.model === model;\n        });\n        this.removeChildView(view);\n    }\n    /**\n     * Called when the collection is sorted\n     * @private\n     */\n    _onCollectionSort() {\n        debug('%s received sort event from collection %s', this, this.collection);\n        let orderChanged = this.collection.find((model, index) => {\n            let view = orange_1.find(this.children, function (view) {\n                return view.model === model;\n            });\n            return !view || view._index !== index;\n        });\n        if (orderChanged)\n            this.render();\n    }\n}\nexports.CollectionView = CollectionView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/collection-view.js\n ** module id = 20\n ** module chunks = 0\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict'\n\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nfunction init () {\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i]\n    revLookup[code.charCodeAt(i)] = i\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n}\n\ninit()\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-js/lib/b64.js\n ** module id = 22\n ** module chunks = 0\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 23\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/isarray/index.js\n ** module id = 24\n ** module chunks = 0\n **/","\"use strict\";\nconst orange_1 = require('orange');\nfunction attributes(attrs) {\n    return function (target) {\n        orange_1.extend(target.prototype, attrs);\n    };\n}\nexports.attributes = attributes;\nfunction events(events) {\n    return function (target) {\n        target.prototype.events = events;\n    };\n}\nexports.events = events;\nfunction triggers(triggers) {\n    return function (target) {\n        target.prototype.triggers = triggers;\n    };\n}\nexports.triggers = triggers;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/annotations.js\n ** module id = 25\n ** module chunks = 0\n **/"],"sourceRoot":""}